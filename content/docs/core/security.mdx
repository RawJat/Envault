---
title: Security
description: Security practices and standards
---

# Security Best Practices

## Master Key Management

The `ENCRYPTION_KEY` is the crown jewel of your Envault instance.

- **Storage**: Never commit this to version control. This is your **"Secret Zero"** and should be injected at runtime via your infrastructure provider (e.g., Vercel Dashboard, Railway Variables, or Docker `.env`).
- **Rotation**: If you suspect the Master Key is compromised, you must immediately rotate it. This involves:
  1. Generating a new key.
  2. Decrypting all Data Keys with the old Master Key.
  3. Re-encrypting all Data Keys with the new Master Key.
  4. Updating the environment variable.

## Key Rotation Policies

Envault supports key rotation for Data Keys. This limits the "blast radius" if a single Data Key is compromised. Only the secrets encrypted with that specific Data Key would be at risk, not the entire database.

## Transport Security

- All communication between the CLI and the Server occurs over **HTTPS**.
- We recommend using **HSTS** (HTTP Strict Transport Security) on your production deployment.

## Database Security

- **RLS (Row Level Security)**: We use Supabase RLS to ensure that users can only access data rows they are explicitly permitted to see. Even if the application logic fails, the database layer attempts to prevent unauthorized access.

## Authentication Security

- **Passkeys (WebAuthn)**: Envault supports passwordless authentication using WebAuthn. This provides phishing-resistant, biometric login capabilities and significantly improves account security compared to traditional passwords.

## CLI Security

- **Rolling Sessions**: For interactive users, the Envault CLI stores long-lived Refresh Tokens securely within the native OS Secure Enclave (e.g., macOS Keychain, Windows Credential Manager) rather than plaintext files. Short-lived Access Tokens (valid for 1 hour) are used for API requests.
- **Service Token Guardrails**: Headless machine workflows use project-scoped Service Tokens. To prevent devastating local leakages, the CLI enforces strict Context Awareness, actively rejecting any Service Tokens executed on local developer machines unless it verifies it is running in a recognized CI/CD environment.
